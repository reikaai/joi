---
phase: 04-isolated-variable-experiments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/eval/evaluators.py
  - tests/eval/test_tasks.py
autonomous: true
requirements:
  - EXPR-02
must_haves:
  truths:
    - "Evaluator correctly filters schedule calls using schedule_tool_names (plural) when set on a variant"
    - "Staggered timing check works for any tool name, not just hardcoded schedule_task/do_later"
    - "Negative test correctly identifies false triggers for multi-tool variants"
    - "A dry-run with --count=1 -k rename passes for all 12 scenarios without evaluator errors"
  artifacts:
    - path: "tests/eval/evaluators.py"
      provides: "Fixed evaluate_tool_calls with multi-tool support, fixed _check_staggered_timing without hardcoded names"
      contains: "schedule_tool_names"
    - path: "tests/eval/test_tasks.py"
      provides: "Fixed test_negative with multi-tool filtering"
      contains: "schedule_tool_names"
  key_links:
    - from: "tests/eval/evaluators.py"
      to: "tests/eval/variants/registry.py"
      via: "ToolVariant.schedule_tool_names field"
      pattern: "variant\\.schedule_tool_names"
    - from: "tests/eval/test_tasks.py"
      to: "tests/eval/variants/registry.py"
      via: "ToolVariant.schedule_tool_names field"
      pattern: "variant\\.schedule_tool_names"
---

<objective>
Fix evaluator bugs that produce incorrect results for non-baseline variants.

Purpose: Without these fixes, the rename variant scores 0% on staggered-timing scenarios (hardcoded tool name check), and the applike variant misses reminders_create calls entirely (single-name filtering). Running experiments on a broken evaluator produces uninterpretable garbage.

Output: Fixed evaluators.py and test_tasks.py that correctly handle all variant tool names.
</objective>

<execution_context>
@/Users/iorlas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/iorlas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-isolated-variable-experiments/04-RESEARCH.md
@tests/eval/evaluators.py
@tests/eval/test_tasks.py
@tests/eval/variants/registry.py
@tests/eval/variants/tasks_rename.py
@tests/eval/variants/tasks_simplify.py
@tests/eval/variants/tasks_applike.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix evaluator multi-tool and hardcoded-name bugs</name>
  <files>tests/eval/evaluators.py, tests/eval/test_tasks.py</files>
  <action>
Fix three bugs in evaluators.py and one in test_tasks.py:

**evaluators.py — evaluate_tool_calls() (line 113):**
Replace the single-name schedule call filter:
```python
schedule_calls = [tc for tc in all_tool_calls if tc["name"] == variant.schedule_tool_name]
```
With multi-tool-aware filtering:
```python
schedule_names = variant.schedule_tool_names or [variant.schedule_tool_name]
schedule_calls = [tc for tc in all_tool_calls if tc["name"] in schedule_names]
```

Also update the failure message (line 144) to use `schedule_names` instead of `variant.schedule_tool_name`.

**evaluators.py — _check_staggered_timing() (lines 34-62):**
Remove the hardcoded tool name gates (`sname in ("schedule_task", "tasks")` on line 39 and `sname in ("schedule_task", "do_later")` on line 49). The function should:
1. First check for `delay_seconds` presence in args — if any call has it, verify strictly increasing.
2. If no delay_seconds found, check for integer `when` values — if all are ints, verify strictly increasing.
3. If neither, check for distinct string `when` values.
This logic works for ALL variants without name-gating. See research code example "Fix 2".

**test_tasks.py — test_negative() (line 148):**
Replace the single-name filter:
```python
schedule_calls = [tc for tc in response.tool_calls if tc["name"] == variant.schedule_tool_name]
```
With multi-tool-aware filtering:
```python
schedule_names = variant.schedule_tool_names or [variant.schedule_tool_name]
schedule_calls = [tc for tc in response.tool_calls if tc["name"] in schedule_names]
```

Run `ruff check tests/eval/evaluators.py tests/eval/test_tasks.py` after changes.
  </action>
  <verify>
Run a dry-run with the rename variant to verify the staggered timing fix works:
```bash
uv run pytest -m eval --count=1 -k "rename and (seq or oneshot)" -v --tb=short 2>&1 | head -50
```
The rename variant should not fail with "delay_seconds not strictly increasing" or staggered timing errors.

Also verify linting: `ruff check tests/eval/evaluators.py tests/eval/test_tasks.py`
  </verify>
  <done>
- evaluate_tool_calls() uses schedule_tool_names (plural) when available
- _check_staggered_timing() has no hardcoded tool name gates
- test_negative() uses schedule_tool_names (plural) when available
- ruff check passes with no errors on both files
- Dry-run of rename variant completes without evaluator-caused failures
  </done>
</task>

</tasks>

<verification>
1. `ruff check tests/eval/evaluators.py tests/eval/test_tasks.py` — no errors
2. `uv run pytest -m eval --count=1 -k "rename" -v --tb=short` — rename variant runs without evaluator bugs
3. `uv run pytest -m eval --count=1 -k "simplify" -v --tb=short` — simplify variant runs without staggered timing errors
</verification>

<success_criteria>
- All evaluator hardcoded tool name references removed
- Multi-tool filtering (schedule_tool_names) used in both evaluators.py and test_tasks.py
- Dry-run confirms rename and simplify variants produce meaningful (non-zero) results on positive scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/04-isolated-variable-experiments/04-01-SUMMARY.md`
</output>
